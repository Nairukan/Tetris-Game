#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow> //Подключение библиотеки содержащей в себе класс стандартного полноценного окна
#include <QWidget> //Подключение библиотеки содержащей в себе класс Окна
#include <cmath> //Подключение библиотеки математических оппераций
#include <QPainter> //Подключение библиотеки содержащей в себе класс устройства лоя рисования
#include <QTimer> //Подключение библиотеки содержащей в себе класс объекта окна "Таймера"
#include <cstdlib> //для работы с rand()
#include <QPushButton> //Подключение библиотеки содержащей в себе класс объекта окна "Кнопка"
#include <QMessageBox> //Подключение библиотеки содержащей в себе класс вплывающего окна
#include <ctime> //для работы со временем, для srand(time(0));
#include <QKeyEvent> //Библиотека для обработки нажатий на клавиатуру
#include <QLabel> //Подключение библиотеки содержащей в себе класс объекта окна "Надпись"
#include <QTextCodec> //Библиотека для перекодировки текстовой информации для корректного хранения
#include <windows.h> //для программной установки раскладки клавиатуры

struct Block{ //Структура одного кубика фигуры
    int posX, posY; //Координаты на поле
    int color; //Цвет, определяется смещением текстуры блока в файле ресурсов
    Block(){
       posX=0; posY=0; color=0; //Конструктор по умолчанию(без параметров) обнуляет значения
    }
    Block(int posX, int posY, int color){ //Конструтор с параметрами, в данном случае настоящий сеттер, который по параметрам устанавливает значения
        this->posX=posX;
        this->posY=posY;
        this->color=color;
    }
    void move(std::pair<int, int> pos){ //Функция-член Перемещения блока, на вход подаются 2 переменные в фигурных скобках через запятую, обазначающие новую позицию блока
        posX=pos.first;
        posY=pos.second;
    }
};

struct Figure{ //Структура фигуры
    std::vector <Block*> Elem; //Вектор, Динамический массив указателей на блоки
    std::vector <std::pair<int, int> > Start; //Координаты начальной позиции при появлении
    std::pair <int, int> RotateCenter; //Установка координат, относительно поля действия фигуры вокруг которой будет происходить вращение,
    QRect  RecBoundsModel, StartRec; //прямоугольники границ фигуры и начальный прямоугольник
    bool Rotateble=false; //Показатель может ли вращаться фигура
    int StartX, StartY; //Начальная позиция фигуры

    Figure(std::pair<int,int> f, std::pair<int,int> s, std::pair<int,int> t, std::pair<int,int> fo, QRect RecBoundsModel, bool Rotateble=false, std::pair<int, int> RotCent={0, 0})
    //Конструктор принемающий позиции 4 блоков, составляющих фигуру, Прямоугольник границ фигуры, необязательные показатели вращаемости и центра вращения
    {
        srand(time(0)); //Устанавливаю новый отсчёт множества псевдослучайных чисел
        int color=rand()%5; //Генерирую случайное значение цвета блоков фигуры
        Elem.push_back(new Block{f.first, f.second, color}); //Добавляю в динамический массив элементов фигуры, новые блоки соответствующие координатам
        Start.push_back(f); //Добавляю в массив начальных координат, координаты первого блока
        Elem.push_back(new Block{s.first, s.second, color});
        Start.push_back(s); //второго
        Elem.push_back(new Block{t.first, t.second, color});
        Start.push_back(t); //третьего
        Elem.push_back(new Block{fo.first, fo.second, color});
        Start.push_back(fo); //четвёртого
        this->Rotateble=Rotateble; //Устанавливаю показатель вращения
        this->RecBoundsModel=RecBoundsModel; //Поля действия фигуры
        StartRec=RecBoundsModel;  //Начальное поле действия совпадает с полем фигуры на этапе создания
        this->RotateCenter=RotCent; //Центра вращения
    }
    void UpdatePos()//Востановление фигуры в начальных координатах
    {
        for (int i=0; i<4; i++) //Проходим по всем элементам
            Elem[i]->move(Start[i]); //Перемещаем блоки к начальным позициям
        RecBoundsModel=StartRec; //Востанавливаем границв дейстаиы фигуры
    }
    void Rotate()//Вращение фигуры по часовой стрелке
    {
        if (Rotateble){ //Проверяем может ли вращаться фигура
            for (int i=0; i<4; i++){ //проходим по всем элементам
                //вычисляем координаты блока относительно центра вращения
                int tx=Elem[i]->posX-RecBoundsModel.x()-RotateCenter.first;
                int ty=Elem[i]->posY-RecBoundsModel.y()-RotateCenter.second;

                //вычисляем новые координаты блока при вращении
                int ttx=ty, tty=-tx; //Смотри картиночку

                //Устанавливаю координаты блока
                Elem[i]->posX=ttx+RotateCenter.first+RecBoundsModel.x();
                Elem[i]->posY=tty+RotateCenter.second+RecBoundsModel.y();
            }
        }
    }
    void UPD_color(unsigned short a){ //Функция обновления цвета блоков
        for (int i=0; i<4; i++){ //Проход по всем блокам
            Elem[i]->color=a; //Установление цвета
        }
    }
    Figure MakeCopy(){ //Функция возращающая свою копию
        return Figure({Elem[0]->posX, Elem[0]->posY}, {Elem[1]->posX, Elem[1]->posY}, {Elem[2]->posX, Elem[2]->posY}, {Elem[3]->posX, Elem[3]->posY}, RecBoundsModel, Rotateble, RotateCenter);
    }
};



QT_BEGIN_NAMESPACE
namespace Ui { class MainWindow; } // Определение UI-класса наперёд, чтобы визуальное редактирование не приводило к крупным перекомпиляциям
QT_END_NAMESPACE

class MainWindow : public QMainWindow //Наследуем всё из стандартного класса окна
{
    //Макрос, определяющий данных класс как объект Qt, и добавляет необходимые функции для компиляции
    Q_OBJECT

public: //Флаг доступа "публичный", к данным членам можно обращаться извне класса
    MainWindow(QWidget *parent = nullptr); //Конструктор с параметром по умолчанию, указатель на родительское окно, если окно самостоятельное то parent==nullptr
    ~MainWindow(); //Деструктор
    void paintEvent(QPaintEvent *event); //Переопределяем базовую функцию отрисовки, в QMainWindow это функция находится в private: и нельзя изменить её, для этого мы создаём функцию с той же сигнатурой и именем, но уже в public:
    void keyPressEvent(QKeyEvent *event); //Переопределяем функцию, вызываемую нажатием клавиши клавиатуры
    void keyReleaseEvent(QKeyEvent *event); //Переопределяем функцию, вызываемую отпусканием клавиши клавиатуры
    void resizeEvent(QResizeEvent * event); //Переопределяем функцию, вызываемую изменением размера окна
    void StopFallFigure(); //Функция остановки падения фигуры, вызывается когда фигура встречает препятствие
    void GameOver(); //Функция конца игры, вызывается когда активная фигура пересекается хотя бы с одним полем блока
    void RotateActiveFigure(); //Функция вращения активной фигуры
    void ReadScores(); //Функция считывания из файла Рекордов и занесения их в вектор
    void SortScores(); //Функция сортировки Рекордов, удаления лишних, Вывод их на экран
    void WriteScores(); //Функция записи в файл Рекордов
    void TakeNickname(QString Nick); //Функция Получения Никнейма игрока (вызывается в окне регистрации)

    QString Nickname; //Никнейм
    std::map <std::pair<int,int>, Block*> BB; //Словарь в кототром некоторой паре значений типа инт, соответствует указатель на элемент стуртуры "Блок"
  //Работает как игровое поле где паре координат, соответствует указатель на элемент находящийся по этим координатам, nullptr - если данная клетка пуста

    QImage BlocksImGL;//Изображение ресурсов для отрисовки, текстур
    std::vector<Figure*> Figures; //Вектор, динамический массив STL, указателей на фигуры
    QTimer* Ti=nullptr, *SDown, *GLOBAL_Timer; //Указатели на стандартные объекты "Таймер": 1-Таймер определяющий падение фигуры в нормальом режиме, 2-Таймер определяющий ускоренное падение первое время после
  //нажатия на кнопку S, при её отпускании разрушает таймер, однако отпускание срабатывает циклически сам по себе если не отпускать кнопку, до этого момента мы будем ускоренно опускать фигуру с помощью таймера,
  //однако потом займётся функция отпускания клавиши, 3-Обуславлевает постепенное уменьшение интервала первого таймера
    bool Cr=false, Suport=false; //Логические показатели: 1-Показатель необходимости генерации новой активной фигуры, 2-Показатель нажата и не отпущена ли кнопка S
    Figure* thisFigure=nullptr, *NextFigure=nullptr; //Указатели на фигуры: 1-Текущая активная фигура, 2-Следующая активная фигура
    QPushButton *B=nullptr; //Указатель на кнопку, начала игры
    QLabel* SC=nullptr; //Указатель на надпись со счётом игрока
    unsigned long long Score=0; //Счёт игрока
    std::vector<std::pair <QString, int> > Scores; //Вектор пар значений <Имя рекордсмена, Его счёт>
    std::vector <QLabel*> SCL; //Вектор указателей на надписи Рекордов
public slots: //Публичные слоты, Слоты - фишка Qt, которые явно показывает что к ним можно подключить некторые сигналы, их вызывающие
    void Tick(); //Функция Падения активной фигуры в нормальном режиме
    void FastTick(); //Ускоренное падение
    void Faster(); //Ускорение нормального падения
    void Start(); //Сброс игрового процесса, подготовка к игровой сессии
private slots:
    void on_action_triggered(); //Выбор в строке меню, пункта "Управление"

    void on_action_2_triggered(); //Выбор в строке меню, пункта "Правила"

private: //флаг доступа private: обеспечивает доступ к следующим элементам только внутри данного класса
    Ui::MainWindow *ui;
};
#endif // MAINWINDOW_H
